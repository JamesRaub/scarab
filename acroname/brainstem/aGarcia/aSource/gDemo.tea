/* gDemo.tea (moto,10) */
/* basic demo program */


#include "gCommon.tea"
#include "gMulti.tea"
#include <aSP03.tea>
#include <aI2C.tea>

#define SPEED_IRMODE	12
#define SPEED_ROAMING	20
#define SPEED_CREEP	4
#define	WHTHRESHOLD	250
#define	FRONTERRTHR	220
#define	IRTIMEOUT	3000 /* 30 seconds */

#define	FRONTMASK	(1<<aGARCIA_GP_BIT_ENABLEFRONT)
#define	DOWNMASK	(1<<aGARCIA_GP_BIT_ENABLEDOWN)

#define STATE_MOVE_FORWARD	1
#define STATE_FORWARD_ERROR	2
#define STATE_BACKUP		3
#define STATE_TURN		4
#define STATE_TURN_ERROR	5

char state = STATE_MOVE_FORWARD;
char lastdown = 0;
char sp03flag = 0;
char turn = 0;
int error = 0;



int roamturn(int r)
{
  if (sp03flag)
  if (r > 0) {
    aSP03_SpeakString(0, 4, 1, "turning left");
    turn = 1;
  } else {
    aSP03_SpeakString(0, 4, 1, "turning right");
    turn = 0;
  }
  error = gMulti_Pivot(r);
  if (sp03flag) aSP03_WaitForCompletion();
  return error;
}

int roamseek(int r)
{
  int v;
  char q;
  int status = 0;

  if (r > 0) {
    if (sp03flag) aSP03_SpeakString(0, 4, 1, "turning left");
    turn = -1;
    q = aGARCIA_MOTO_ARANGE_FRONT_RIGHT;
  } else {
    if (sp03flag) aSP03_SpeakString(0, 4, 1, "turning right");
    turn = 1;
    q = aGARCIA_MOTO_ARANGE_FRONT_LEFT;
  }
  if (sp03flag) aSP03_WaitForCompletion();

  /* enable forward sensors, wait to ensure enable */
  gc_write_padb_gp(aGARCIA_GP_PADB_MIRRORMASK, ~FRONTMASK);
  gc_write_padb_gp(aGARCIA_GP_PADB_MIRRORIO, FRONTMASK);
  gc_const_sleep(2500);

  gc_const_wrpadb(aGARCIA_MOTO_PADB_ENDFLAGS, 0);

  /* restart monitor */
  gc_aClrStatus;
  gc_aMonEnable;

  /* give time for monitors to stabilize */
  gc_const_sleep(750);

  /* rotate away from sensor with detection to find clear path */
  v = SPEED_CREEP * turn;
  aMotion_SetVelocity(-v, v);
  while (1)
  {
    if (gc_aGetStatus) break;
    if ((gc_range(aGARCIA_MOTO_ARANGE_FRONT_LEFT) < 80) && (gc_range(aGARCIA_MOTO_ARANGE_FRONT_RIGHT) < 80)) {
      /* throw in a tiny bit of bias */
      if (v & 0x8000) {
        gc_const_sleep(4000);
      } else {
        gc_const_sleep(2000);
      }
      break;
    }
  }
  aMotion_SetVelocity(0, 0);
  gc_const_sleep(1000);

  /* motion done so turn monitors off */
  gc_write_padb_gp(aGARCIA_GP_PADB_MIRRORMASK, ~FRONTMASK);
  gc_write_padb_gp(aGARCIA_GP_PADB_MIRRORIO, 0);
  gc_aMonDisable;

  return status;
}



void roam()
{
  int error;

  if (sp03flag)
  {
    aSP03_SpeakString(0, 4, 1, "roaming demonstration mode");
    aSP03_WaitForCompletion();
  }

  /* enable edge check, IR check, and user mode */
  gc_const_wrpadb(aGARCIA_MOTO_PADB_EXEFLAGS, aGARCIA_EXECTRL_USER | aGARCIA_EXECTRL_EDGECHK | aGARCIA_EXECTRL_IRCHK | aGARCIA_EXECTRL_STALLCHK);
  gc_const_wrpads(aGARCIA_MOTO_PADS_DEFVEL, SPEED_ROAMING);

  state = STATE_MOVE_FORWARD;
  while (1)
  {
    error = roam_state_action(state);
    if (error == aGARCIA_ERRFLAG_IRRX) break;
  }
}

int roam_state_action(char a)
{
  char stackfixbyte = 0;
  char exeflags;

  switch (a)
  {
    case STATE_MOVE_FORWARD:
      /* move forward */
      if (sp03flag) aSP03_SpeakString(0, 4, 1, "moving forward");
      error = gMulti_Move(0x0000, aGARCIA_TICKS_PER_FOOT * 10);
      if (sp03flag) aSP03_WaitForCompletion();
      if (error) {
        state = STATE_FORWARD_ERROR;
      } else {
        state = STATE_MOVE_FORWARD;
      }
      break;

    case STATE_FORWARD_ERROR:
    {
      if (error == aGARCIA_ERRFLAG_STALL) {
        if (sp03flag)
        {
          aSP03_SpeakString(0, 4, 1, "motor stall");
          aSP03_WaitForCompletion();
        }
        lastdown = 0;
        aDig_Write(aGARCIA_MOTO_DLED_USER, 0);
        gc_const_sleep(2500);
        aDig_Write(aGARCIA_MOTO_DLED_USER, 1);
        state = STATE_BACKUP;
      } else if ((error == aGARCIA_ERRFLAG_FALL_LEFT) || (error == aGARCIA_ERRFLAG_FALL_RIGHT)) {
        if (sp03flag)
        {
          aSP03_SpeakString(0, 4, 1, "ledge detected");
          aSP03_WaitForCompletion();
        }
        lastdown = 0;
        if (error == aGARCIA_ERRFLAG_FALL_RIGHT) lastdown = 1;
        state = STATE_BACKUP;
      } else {
        if (sp03flag)
        {
          aSP03_SpeakString(0, 4, 1, "obstacle ahead");
          aSP03_WaitForCompletion();
        }
        state = STATE_TURN;
      }
      break;
    }

    case STATE_BACKUP:
    {
      /* disable down-rangers so it is possible to back away from ledge */
      exeflags = gc_read_padb(aGARCIA_MOTO_PADB_EXEFLAGS);
      gc_write_padb(aGARCIA_MOTO_PADB_EXEFLAGS, exeflags & ~aGARCIA_EXECTRL_EDGECHK);
//    gc_write_padb_gp(aGARCIA_GP_PADB_MIRRORMASK, ~DOWNMASK);
//    gc_write_padb_gp(aGARCIA_GP_PADB_MIRRORIO, 0);
      gc_const_sleep(2500);

      if (sp03flag) aSP03_SpeakString(0, 4, 1, "backing up");
      error = gMulti_Move(0xFFFF, -aGARCIA_TICKS_PER_FOOT/4);
      if (sp03flag) aSP03_WaitForCompletion();

      /* when turning down-rangers on and off via enable */
      /* this delay makes things work, don't know why */
      /* (without it, edge sensors don't get re-enabled) */
      gc_const_sleep(5000);

      exeflags = gc_read_padb(aGARCIA_MOTO_PADB_EXEFLAGS);
      gc_write_padb(aGARCIA_MOTO_PADB_EXEFLAGS, exeflags | aGARCIA_EXECTRL_EDGECHK);
//    gc_write_padb_gp(aGARCIA_GP_PADB_MIRRORMASK, ~DOWNMASK);
//    gc_write_padb_gp(aGARCIA_GP_PADB_MIRRORIO, DOWNMASK);
      gc_const_sleep(2500);

      /* turn away */
      if (sp03flag) aSP03_SpeakString(0, 4, 1, "turn away");
      error = gMulti_Pivot(aGARCIA_TICKS_PER_360DEGREES/3);
      if (sp03flag) aSP03_WaitForCompletion();

      state = STATE_MOVE_FORWARD;
      break;
    }

    case STATE_TURN:
      if (error == aGARCIA_ERRFLAG_FRONTR_LEFT) {
        error = roamseek(-aGARCIA_TICKS_PER_360DEGREES/3);
      } else if (error == aGARCIA_ERRFLAG_FRONTR_RIGHT) {
        error = roamseek(aGARCIA_TICKS_PER_360DEGREES/3);
      } else if (1) {
        error = roamturn(-aGARCIA_TICKS_PER_360DEGREES/8);
      } else {
        error = roamturn(aGARCIA_TICKS_PER_360DEGREES/6);
      }
      if (error) {
        state = STATE_TURN_ERROR;
      } else {
        state = STATE_MOVE_FORWARD;
      }
      break;

    case STATE_TURN_ERROR:
      if (sp03flag)
      {
        aSP03_SpeakString(0, 4, 1, "turn done");//"couldn't turn");
        aSP03_WaitForCompletion();
      }
      state = STATE_MOVE_FORWARD;//STATE_BACKUP;
      break;
  }
  return error;
}


void go_parallel_after_align(char side)
{
  int error = 0;
  int fthr;
  fthr = gc_read_pads(aGARCIA_MOTO_PADS_FRONTTHR);
  gc_write_pads(aGARCIA_MOTO_PADS_FRONTTHR, 450);

  if (side == aGARCIA_MOTO_ARANGE_FRONT_LEFT)
  {
    error = gMulti_Move(0,500);
    if (error == 0)
      error = gMulti_Turn(aGARCIA_MOTO_MOTOR_LEFT,1800);
  }
  else
  {
    error = gMulti_Move(0,500);
    if (error == 0)
      error = gMulti_Turn(aGARCIA_MOTO_MOTOR_RIGHT,1800);
  }
  gc_write_pads(aGARCIA_MOTO_PADS_FRONTTHR, fthr);
}



void handle_ir_commands()
{
  int n;
  int k;
  int error;

  if (sp03flag)
  {
    aSP03_SpeakString(0, 4, 1, "remote control mode");
    aSP03_WaitForCompletion();
  }
  
  gc_const_wrpadb(aGARCIA_MOTO_PADB_EXEFLAGS, aGARCIA_EXECTRL_USER | aGARCIA_EXECTRL_EDGECHK | aGARCIA_EXECTRL_STALLCHK);
  gc_const_wrpads(aGARCIA_MOTO_PADS_DEFVEL, SPEED_IRMODE);
  aCore_Outporti(0x03A6,0);
  
  while (1)
  {
    n = 0;
    k = 0;
    while (n == 0)
    {
      n=aCore_Inporti(0x03A6);
      gc_const_sleep(100);
      k++;
      if (k == IRTIMEOUT) break;
    }

    /* break if no IR commands found in interval */
    if (k == IRTIMEOUT) break;

    n=n&0x00FF;

    aPrint_IntHex(n);
    aPrint_Char('\n');

    
    switch (n)
    {
      case 21:
      {
        if (sp03flag) {
          aSP03_SpeakString(0,4,3,"going straight");
          aSP03_WaitForCompletion();
        }
        error = gMulti_Move(0x0000, aGARCIA_TICKS_PER_FOOT);
        break;
      }
      case 14:
      {
        if (sp03flag) {
          aSP03_SpeakString(0,4,3,"turning left");
          aSP03_WaitForCompletion();
        }
        error = gMulti_Pivot(aGARCIA_TICKS_PER_360DEGREES/8);
        break;
      }
      case 12:
      {
        if (sp03flag) {
          aSP03_SpeakString(0,4,3,"turning right");
          aSP03_WaitForCompletion();
        }
        error = gMulti_Pivot(-aGARCIA_TICKS_PER_360DEGREES/8);
        break;
      }
      case 9:
      {
        if (sp03flag) {
          aSP03_SpeakString(0,4,3,"backing up");
          aSP03_WaitForCompletion();
        }
        error = gMulti_Move(0xFFFF, -aGARCIA_TICKS_PER_FOOT);
        break;
      }
      case 10:
      {
        if (sp03flag) {
          aSP03_SpeakString(0,4,3,"seek left hug");
          aSP03_WaitForCompletion();
        }
        error = 0;

        if (error == 0)
          error = gMulti_Move(0x0001,0x174C);

        if ((error == aGARCIA_ERRFLAG_FRONTR_LEFT) || (error == aGARCIA_ERRFLAG_FRONTR_RIGHT))
        {
          gc_const_wrpads(aGARCIA_MOTO_PADS_DEFVEL, 3);
          error = gMulti_Align(aGARCIA_MOTO_ARANGE_FRONT_LEFT, aGARCIA_ALIGNMODE_DEFAULT, WHTHRESHOLD);
          gc_const_wrpads(aGARCIA_MOTO_PADS_DEFVEL, SPEED_IRMODE);
        }
        if (error == 0)
          go_parallel_after_align(aGARCIA_MOTO_ARANGE_FRONT_LEFT);

        if (error == 0)
          error = gMulti_Hug(aGARCIA_MOTO_ARANGE_SIDE_LEFT, 0, WHTHRESHOLD);

        break;
      }
      case 20:
      {
        if (sp03flag) {
          aSP03_SpeakString(0,4,3,"seek right hug");
          aSP03_WaitForCompletion();
        }
        error = 0;

        if (error == 0)
          error = gMulti_Move(0x0001,0x174C);

        if ((error == aGARCIA_ERRFLAG_FRONTR_LEFT) || (error == aGARCIA_ERRFLAG_FRONTR_RIGHT))
        {
          gc_const_wrpads(aGARCIA_MOTO_PADS_DEFVEL, 3);
          error = gMulti_Align(aGARCIA_MOTO_ARANGE_FRONT_RIGHT, aGARCIA_ALIGNMODE_DEFAULT, WHTHRESHOLD);
          gc_const_wrpads(aGARCIA_MOTO_PADS_DEFVEL, SPEED_IRMODE);
        }
        if (error == 0)
          go_parallel_after_align(aGARCIA_MOTO_ARANGE_FRONT_RIGHT);

        if (error == 0)
          error = gMulti_Hug(aGARCIA_MOTO_ARANGE_SIDE_RIGHT, 0, WHTHRESHOLD);
        break;
      }

      case 5:
      {
        if (sp03flag) {
          aSP03_SpeakString(0,4,3,"square yard");
          aSP03_WaitForCompletion();
        }
        error = gMulti_Move(0x0000, 3*aGARCIA_TICKS_PER_FOOT);
        if (error == 0)
          error = gMulti_Pivot(aGARCIA_TICKS_PER_360DEGREES/4);
        if (error == 0)
          error = gMulti_Move(0x0000, 3*aGARCIA_TICKS_PER_FOOT);
        if (error == 0)
          error = gMulti_Pivot(aGARCIA_TICKS_PER_360DEGREES/4);
        if (error == 0)
          error = gMulti_Move(0x0000, 3*aGARCIA_TICKS_PER_FOOT);
        if (error == 0)
          error = gMulti_Pivot(aGARCIA_TICKS_PER_360DEGREES/4);
        if (error == 0)
          error = gMulti_Move(0x0000, 3*aGARCIA_TICKS_PER_FOOT);
        if (error == 0)
          error = gMulti_Pivot(aGARCIA_TICKS_PER_360DEGREES/4);
      }

    }

    if (sp03flag) {
      if (error != 0)
      {
        aSP03_SpeakString(0,4,3,"error");
        aSP03_WaitForCompletion();
      }
      else
      {
        aSP03_SpeakString(0,4,3,"success");
        aSP03_WaitForCompletion();
      }
    }

    aCore_Outporti(0x03A6,0);
    gc_const_sleep(2500);
  }
}



void main() 
{
  char sp03ver;
  
  /* turn on user LED */
  gc_const_wrLED(1);

  /* this is a TEA application calling TEA primitives */
  gc_const_wrpadb(aGARCIA_MOTO_PADB_EXEFLAGS, aGARCIA_EXECTRL_USER | aGARCIA_EXECTRL_EDGECHK | aGARCIA_EXECTRL_IRCHK | aGARCIA_EXECTRL_STALLCHK);

  gc_const_sleep(10000);

  /* check for presence of SP03 */
  aCore_Outportc(aPortIICBaud, 0);
  sp03ver = aI2C_ReadChar((unsigned char)0xC4, 1);
  if ((sp03ver > 0) && (sp03ver != -1)) sp03flag = 1;
  aCore_Outportc(aPortIICBaud, 2);

  gc_const_sleep(10000);

  while (1)
  {
    roam();
    handle_ir_commands();
  }
}
