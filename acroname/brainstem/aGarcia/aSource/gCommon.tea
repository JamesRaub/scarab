/* gCommon.tea                            */
/* common stuff for the Garcia primitives */


/*----------------------*/
/* LIBRARIES AND MACROS */
/*----------------------*/
#include <aGarciaDefs.tea>
#include <aCore.tea>
#include <aPrint.tea>
#include <aMotion.tea>
#include <aA2D.tea>
#include <aDig.tea>
#include <aMulti.tea>
#include <aGarcia.tea>

#define gc_const_sleep(i)	asm { pushls i popsm aPortVMTimer }
#define gc_const_wrpadb(x, i)	asm { pushlb i popbm aPortScratch + x }
#define gc_const_wrpads(x, i)	asm { pushls i popsm aPortScratch + x }
#define gc_const_wrctr(x, i)	asm { pushls i popsm aPortRflxCtr + x }
#define gc_const_wrLED(i)	asm { pushlb i popbm aPortRawInput + aGARCIA_MOTO_RFLX_LED }
#define gc_aClrEnc32	asm { pushls 0 pushls 0 pushls 0 pushls 0 popsm 0x061D popsm 0x061E popsm 0x060D popsm 0x060E }
#define	gc_aClrStatus		asm { pushls 0 popsm aPortScratch + aGARCIA_MOTO_PADS_STATUS }
#define	gc_aMonDisable		asm { pushlb 0 popbm aPortScratch + aGARCIA_MOTO_PADB_MONENABLE }
#define	gc_aMonEnable		asm { pushlb 1 popbm aPortScratch + aGARCIA_MOTO_PADB_MONENABLE }
#define	gc_aGetStatus		aCore_Inporti(aPortScratch + aGARCIA_MOTO_PADS_STATUS)
#define	gc_aMonEnabled		aCore_Inportc(aPortScratch + aGARCIA_MOTO_PADB_MONENABLE)
#define gc_write_padb(x, i)	aCore_Outportc(aPortScratch + x, i)
#define gc_write_pads(x, i)	aCore_Outporti(aPortScratch + x, i)
#define gc_read_padb(x)		aCore_Inportc(aPortScratch + x)
#define gc_read_pads(x)		aCore_Inporti(aPortScratch + x)
#define gc_write_ctr(x, i)	aCore_Outporti(aPortRflxCtr + x, i)
#define gc_read_ctr(x)		aCore_Inporti(aPortRflxCtr + x)
#define gc_write_ctr_mo(x, i)	gc_network_cmd_ci(aGARCIA_MOTO_ADDR, cmdCTR_SET, x, i)
#define gc_write_ctr_gp(x, i)	gc_network_cmd_ci(aGARCIA_GP_ADDR, cmdCTR_SET, x, i)
#define gc_write_padb_mo(x, i)	gc_network_cmd_cc(aGARCIA_MOTO_ADDR, cmdPAD_IO, x, i)
#define gc_write_padb_gp(x, i)	gc_network_cmd_cc(aGARCIA_GP_ADDR, cmdPAD_IO, x, i)
#define	gc_range(x)		aA2D_ReadInt(x)



#define	MOVE_DONE_NORM	0
#define	MOVE_DONE_KILL	1

#define	VEL_NORM	9

#define	ACCT_NORM	145
#define	ACCT_WHUG	20

#define	FRTHR_NORM	250

#define	STALLMASK	0x00FF	/* default (number of LSB set determine bit queue size) */

#define	STALL_XSLOPE		(25000/aGARCIA_PID_PERIOD)
#define	STALL_XCONST		524
#define	STALL_ERR		2
#define	STALL_ERR_DOCK		3
#define	STALL_ERR_HUG		3
#define	STALL_LOAD		2
#define	STALL_LOAD_DOCK		3




int gc_ravg(char rx)
{
  int r=0;
  r=r+aA2D_ReadInt(rx);
  r=r+aA2D_ReadInt(rx);
  r=r+aA2D_ReadInt(rx);
  r=r/3;
  return r;
}  

void gc_set_stall_params_old(int v, int sthr, int fac)
{
  int thr;
  int vlimit;

  /* limit input for formula to prevent overflow */
  /* (dervied from experimental data) */
  vlimit = (aGARCIA_MAX_VELOCITY/fac)-1;
  
  if (v & 0x8000) v = -v;
  if (v > vlimit) v = vlimit;
  
  /* calculate upper bound on duty cycle */
  /* this is FAC times "no load" duty cycle to achieve V */
  /* (comes from experimental data) */
  thr = (STALL_XSLOPE*v+STALL_XCONST)*fac;

  /* set PWM rails equal to thr */  
  /* and write new PID error threshold */
  asm
  {
    pushss	4
    popsm	0x0605
    pushss	4
    popsm	0x0615
    pushss	10
    popsm	aPortScratch + aGARCIA_MOTO_PADS_STALLTHR
  }
}

void gc_set_stall_params(int v, int fac)
{
  int thr;
  int vlimit;

  /* limit input for formula to prevent overflow */
  /* (dervied from experimental data) */
  vlimit = (aGARCIA_MAX_VELOCITY/fac)-1;
  
  if (v & 0x8000) v = -v;
  if (v > vlimit) v = vlimit;
  
  /* calculate upper bound on duty cycle */
  /* this is FAC times "no load" duty cycle to achieve V */
  /* (comes from experimental data) */
  thr = (STALL_XSLOPE * v + STALL_XCONST) * fac;

  /* set PWM rails equal to thr */  
  asm
  {
    pushss	4
    popsm	0x0605
    pushss	4
    popsm	0x0615
  }
}

void gc_init_vdamp(int nACCT)
{
  aMotion_SetRampVelocity(0,0);
  asm
  {
    /* set both ramp flag bytes to 1 (enable velocity damping) */
    pushls	0x0001
    pushlb	aMOTION_RMPCFGW + aMOTION_RIFLAG
    popbm	aPortMotion+0*aPortMotionBlockSize+aOffsetMotionRmpCfg
    pushls	0x0001
    pushlb	aMOTION_RMPCFGW + aMOTION_RIFLAG
    popbm	aPortMotion+1*aPortMotionBlockSize+aOffsetMotionRmpCfg

    /* set both ACCDT to nACCT */
    pushss	4
    pushlb	aMOTION_RMPCFGW + aMOTION_RIACCT
    popbm	aPortMotion+0*aPortMotionBlockSize+aOffsetMotionRmpCfg
    pushss	4
    pushlb	aMOTION_RMPCFGW + aMOTION_RIACCT
    popbm	aPortMotion+1*aPortMotionBlockSize+aOffsetMotionRmpCfg
    
    /* enable both ramps (special code) */
    pushlb	0x12
    popbm	aPortMotion
		+aOffsetMotionRmpEna
  }
}

void gc_init_ramp(int nACCT)
{
  asm
  {
    /* set both ACCDT to nACCT */
    pushss	4
    pushlb	aMOTION_RMPCFGW + aMOTION_RIACCT
    popbm	aPortMotion+0*aPortMotionBlockSize+aOffsetMotionRmpCfg
    pushss	4
    pushlb	aMOTION_RMPCFGW + aMOTION_RIACCT
    popbm	aPortMotion+1*aPortMotionBlockSize+aOffsetMotionRmpCfg

    /* set ramp flags (dual trapezoidal ramps, reflex on 1) */
    pushls	0x000A
    pushlb	aMOTION_RMPCFGW + aMOTION_RIFLAG
    popbm	aPortMotion+0*aPortMotionBlockSize+aOffsetMotionRmpCfg
    pushls	(((128 | aGARCIA_MOTO_RFLX_RAMP) << 8) | 0x000A)
    pushlb	aMOTION_RMPCFGW + aMOTION_RIFLAG
    popbm	aPortMotion+1*aPortMotionBlockSize+aOffsetMotionRmpCfg
  }
}

int gc_vdamp_check()
{
  int x = 0;
  asm
  {
    pushms	aPortMotion + 0*aPortMotionBlockSize + aOffsetMotionSetpoint
    pushms	aPortMotion + 1*aPortMotionBlockSize + aOffsetMotionSetpoint
    ors
    popss 2
  }
  return x;
}

void gc_stop_vdamp()
{
  aMotion_SetRampVelocity(0,0);
  while (gc_vdamp_check()) {}

  /* settling time */
  gc_const_sleep(1000);
}

void gc_stop_hard()
{
  asm
  {
    /* disable both ramps (special code) */
    pushlb	0x02
    popbm	aPortMotion
		+aOffsetMotionRmpEna

    /* slam both vels to 0 */
    pushls	0x0000
    popsm	aPortMotion+0*aPortMotionBlockSize+aOffsetMotionSetpoint
    pushls	0x0000
    popsm	aPortMotion+1*aPortMotionBlockSize+aOffsetMotionSetpoint
  }

  /* settling time */
  gc_const_sleep(1000);
}

void gc_stop_soft(char disable)
{
  int v0 = 0;
  int v1 = 0;
  int step0 = -1;
  int step1 = -1;
  
  /* IT WOULD BE NICE TO SWITCH CLEANLY IN FIRMWARE */
  /* FROM TRAPEZOIDAL TO VELOCITY DAMPING MODE */
  
  asm
  {
    /* disable ramp(s) */
    pushsb	11
    popbm	aPortMotion
		+aOffsetMotionRmpEna
		
    /* write setpoints to v0, v1 */
    pushms	aPortMotion+0*aPortMotionBlockSize+aOffsetMotionSetpoint
    popss	8
    pushms	aPortMotion+1*aPortMotionBlockSize+aOffsetMotionSetpoint
    popss	6
  }
  
  /* use positive step to zero negative velocities */
  if (v0 & 0x8000) step0 = 1;
  if (v1 & 0x8000) step1 = 1;

  /* gradually move velocities to zero */
  while (1)
  {  
    if ((v0==0) && (v1==0)) break;
    if (v0!=0) v0 = v0 + step0;
    if (v1!=0) v1 = v1 + step1;
    aMotion_SetVelocity(v0,v1);
    gc_const_sleep(200);
  }
}

void gc_ramp_loop(char side)
{
  int status;
  
  /* merrily we roll along */
  while (1)
  {
    if (gc_aGetStatus) break;
    if (gc_read_padb(aGARCIA_MOTO_PADB_MOVEDONE))
    {
      gc_const_wrpadb(aGARCIA_MOTO_PADB_MOVEDONE, 0);
      break;
    }
  }

  /* we've stopped */  
  status = gc_aGetStatus;
  if (status) {
    if ((status == aGARCIA_ERRFLAG_FALL_LEFT) || (status == aGARCIA_ERRFLAG_FALL_RIGHT))
    {
      /* slam on the brakes if about to fall */
      gc_stop_hard();
    }
    else
    {
      /* otherwise ramp down gradually */
      gc_stop_soft(side);
    }
  }

  /* normal settling time */
  gc_const_sleep(500);
}

void gc_perform_dual_ramp()
{
  asm
  {
    /* enable both ramps (special code) */
    pushlb	0x12
    popbm	aPortMotion + aOffsetMotionRmpEna
  }
  
  gc_ramp_loop(aMOTION_RXALL);
}

void gc_network_cmd_ci(char cModule, char cCmd, char cIndex, int arg)
{
  asm
  {
    pushsb 7
    pushlb 4
    pushsb 8
    pushsb 8
    pushss 8
    pushlb 6
    popcmd
    pushlb 10
    popbm  aPortVMTimer
  }
}

void gc_network_cmd_cc(char cModule, char cCmd, char cIndex, char arg)
{
  asm
  {
    pushsb 6
    pushlb 3
    pushsb 7
    pushsb 7
    pushsb 7
    pushlb 5
    popcmd
    pushlb 10
    popbm  aPortVMTimer
  }
}
