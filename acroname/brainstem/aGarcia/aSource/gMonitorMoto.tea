/* mo_monitor.tea (moto,9,1) */
/* Moto board monitor process */

#include "gCommon.tea"



int x1 = 0;
int x0 = 0;
int bitqueue = 0;


void moto_init()
{
  /* initialize any non-zero constants */
  gc_const_wrpads(aGARCIA_MOTO_PADS_DEFVEL, VEL_NORM);
  gc_const_wrpads(aGARCIA_MOTO_PADS_DEFACCTM, ACCT_NORM);
  gc_const_wrpads(aGARCIA_MOTO_PADS_FRONTTHR, FRTHR_NORM);
  gc_const_wrpads(aGARCIA_MOTO_PADS_STALLTHR, STALL_ERR);
  gc_const_wrctr(aGARCIA_MOTO_CTR_STALLMASK, STALLMASK);
  
  /* init digital IO pins */
  aDig_Config(aGARCIA_MOTO_DLED_USER, ADIG_OUTPUT);

  /* ENABLE EDGE AND STALL CHECK */
  gc_const_wrpadb(aGARCIA_MOTO_PADB_EXEFLAGS, aGARCIA_EXECTRL_EDGECHK | aGARCIA_EXECTRL_STALLCHK);
}

void get_pid_error()
{
  asm
  {
    pushlb	0		/* top 4 bytes get errors */
    popbm	0x0620

    pushss	2		/* check sign of top */
    pops
    brpos	asm_enc1chk_pos
    negs
asm_enc1chk_pos:
    popssa	0

    pushss	2		/* check sign of top */
    pops
    brpos	asm_enc0chk_pos
    negs
asm_enc0chk_pos:
    popssa	2
  }
}

void monitor_sensors()
{
  int val = 0;
  int thr = 0;
  char endflags;
  char exeflags;
  char gpstat = 0;
  int status = 0;
  int r0 = 0;
  int r1 = 0;
  
  if (gc_aGetStatus) return;
  
  /* PRIORITY */ 
  /* #1 edge  */
  /* #2 IR    */
  /* #3 front */
  /* #4 rear  */

  /****************************************/
  /* CHECK USER-CONTROLLED END CONDITIONS */
  /****************************************/

  exeflags = gc_read_padb(aGARCIA_MOTO_PADB_EXEFLAGS);

  /* edge */  
  if (!status && (exeflags & aGARCIA_EXECTRL_EDGECHK))
  {
    /* read state of edge detectors into r0, r1 */
    asm
    {
      pushms aPortDigital + aGARCIA_MOTO_DEDGE_LEFT*aPortDigitalBlockSize + aOffsetDigitalIO
      popss 4
      pushms aPortDigital + aGARCIA_MOTO_DEDGE_RIGHT*aPortDigitalBlockSize + aOffsetDigitalIO
      popss 2
    }

    /* tie goes to right side */
    if (r0) status = aGARCIA_ERRFLAG_FALL_LEFT;
    if (r1) status = aGARCIA_ERRFLAG_FALL_RIGHT;
  }

  /* received IR */
  if (!status && (exeflags & aGARCIA_EXECTRL_IRCHK))
  {
    if (gc_read_ctr(aGARCIA_MOTO_CTR_IRRX))
    {
      status = aGARCIA_ERRFLAG_IRRX;
    }
  }

  /*******************************************/
  /* CHECK STANDARD PRIMITIVE END CONDITIONS */
  /*******************************************/
  
  endflags = gc_read_padb(aGARCIA_MOTO_PADB_ENDFLAGS);

  /* (side sensors handled within appropriate primitives) */

  /* forward collision */  
  if (!status && (endflags & aGARCIA_ENDCTRL_FRONT))
  {
    /* read front threshold into thr */
    /* read front detectors values into r0, r1 */
    asm
    {
      pushms aPortScratch + aGARCIA_MOTO_PADS_FRONTTHR
      popss 11
      pushms aPortA2D + aGARCIA_MOTO_ARANGE_FRONT_LEFT*aPortA2DBlockSize + aOffsetAnalogRead
      popss 4
      pushms aPortA2D + aGARCIA_MOTO_ARANGE_FRONT_RIGHT*aPortA2DBlockSize + aOffsetAnalogRead
      popss 2
    }
    
    /* tie goes to right side */
    if (r0>thr) status = aGARCIA_ERRFLAG_FRONTR_LEFT;
    if (r1>thr) status = aGARCIA_ERRFLAG_FRONTR_RIGHT;
  }

  /* rear collision */
  if (!status && (endflags & aGARCIA_ENDCTRL_REAR))
  {
    gpstat = gc_read_padb(aGARCIA_MOTO_PADB_GPSTAT);
    if (gpstat & 1) status = aGARCIA_ERRFLAG_REARR_LEFT;
    if (gpstat & 2) status = aGARCIA_ERRFLAG_REARR_RIGHT;
  }
  
  /*****************/
  /* UPDATE STATUS */
  /*****************/

  if (status)
  {
    /* wipe out any auxillary status flags too */
    gc_const_wrpadb(aGARCIA_MOTO_PADB_GPSTAT, 0);
    gc_write_pads(aGARCIA_MOTO_PADS_STATUS, status);
  }
}

void monitor_pid_stall()
{
  int stallmask = 0;
  int queuechk = 0;
  int sthr = 0x7FFF;

  /* do no further checks if stall check disabled */
  if (!(gc_read_padb(aGARCIA_MOTO_PADB_EXEFLAGS) & aGARCIA_EXECTRL_STALLCHK))
    return;

  /* do no further checks after status change */
  if (gc_aGetStatus) return;

  /* call PID error function (x1a=err1, x0a=err0) */
  get_pid_error();

  /*  write stall threshold to sthr */
  asm
  {
    pushms aPortScratch + aGARCIA_MOTO_PADS_STALLTHR
    popss 2
  }

  /* stall check uses bit flag queue */
  /* must find a sequence of stall bits */
  /* this filters out most normal fluctuations */
  
  bitqueue = bitqueue << 1;
  if ((x1 >= sthr) || (x0 >= sthr))
  {
    bitqueue = bitqueue | 1;
  }

  /*  retrieve stall mask */
  asm
  {
    pushms aPortRflxCtr + aGARCIA_MOTO_CTR_STALLMASK
    popss 6
  }
  queuechk = bitqueue & stallmask;

/*  
    aPrint_IntDec(x1);
    aPrint_Char(',');
    aPrint_IntDec(x0);
    aPrint_Char(',');
    aPrint_IntDec(queuechk);
    aPrint_Char('\n');
*/
    
  if (queuechk == stallmask)
  {
    /* one of the motors is stalled so set stall error code */
    gc_const_wrpads(aGARCIA_MOTO_PADS_STATUS, aGARCIA_ERRFLAG_STALL);
  }
}

void main()
{
  char i;
  moto_init();
  while (1)
  {
    /* the primitives enable the monitor */
    while (!gc_aMonEnabled)
    {
      gc_const_sleep(10);
    }

    /* reset stall monitor */
    /* (flush bit flag queue) */
    bitqueue = 0;
    
    /* poll until monitor is disabled */
    /* first change in status disables all other checks */
    while (gc_aMonEnabled)
    {
      for (i=0; i<3; i++)
      {
        gc_const_sleep(50);
        monitor_sensors();	/* check 100% of the time */
        if (i==0)
        {
          monitor_pid_stall();	/* check some of the time */
        }			/* rate requires some tweaking */
      }
    }
  }
}
